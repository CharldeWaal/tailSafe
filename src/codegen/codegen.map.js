// eslint-disable-next-line @typescript-eslint/no-require-imports
const fs = require('fs');
// eslint-disable-next-line @typescript-eslint/no-require-imports
const { paths } = require('../config/codegen.config');
// eslint-disable-next-line @typescript-eslint/no-require-imports
const tailSafeConfig = require('../config/tailSafe.config.ts').default;

const groupsPath = paths.generated.groups;
const outputPath = paths.generated.map;

const content = fs.readFileSync(groupsPath, 'utf8');

// Map all interfaces to props
// Find all interfaces like: export interface JustifyProps { 'justify'?: JustifyClass; }
// This regex handles quoted property names by specifically capturing the content within the quotes
// This regex captures the prop name (group 1) and its full type definition (group 2).
const propRegex = /'?([\w-]+)'?\?:\s*([^;]+);/g;

let match;
const map = {};
while ((match = propRegex.exec(content))) {
  // We only need the first capture group: the prop name itself.
  const propName = match[1];
  const propType = match[2];

  if (!propType) {
    // eslint-disable-next-line no-console
    console.log("--- DEBUG: Problematic Match Found ---");
    // eslint-disable-next-line no-console
    console.log("Full match text:", match[0]);
    // eslint-disable-next-line no-console
    console.log("Prop name captured:", match[1]);
    // eslint-disable-next-line no-console
    console.log("Prop type captured:", match[2]);
    // eslint-disable-next-line no-console
    console.log("------------------------------------");
    continue; // Temporarily skip this iteration to prevent crashing
  }

  if (propType.includes('boolean')) {
    // This prop can be a boolean, so it needs special mapping.
    // Check if it's a multi-class alias from our config.
    if (propName in tailSafeConfig.aliases) {
      const classNames = tailSafeConfig.aliases[propName];
      const classString = classNames.join(' ');
      // If true, expand to classes; otherwise, pass value through.
      map[propName] = `(v: boolean | string) => (v === true ? '${classString}' : v)`;
    } else {
      // It's a simple boolean utility (e.g., 'flex'), where the class is the prop name itself.
      map[propName] = `(v: boolean | string) => (v === true ? '${propName}' : v)`;
    }
  } else {
    // It's a standard prop, so the value is the class.
    map[propName] = '(v: string) => v';
  }
}

// Convert the map object into the final string format for the file.
const mapEntries = Object.entries(map)
  .sort(([a], [b]) => a.localeCompare(b))
  .map(([prop, fn]) => `  '${prop}': ${fn},`);


const output = `// AUTO-GENERATED FILE. DO NOT EDIT.\n// Generated by tailSafe ðŸ¦ˆ\n\nexport const tailSafeMap = {\n${mapEntries.join('\n')}\n};\n`;

fs.writeFileSync(outputPath, output);
// eslint-disable-next-line no-console
console.log('âœ… Generated tailSafeMap.js, written to', outputPath); 