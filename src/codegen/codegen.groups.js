// eslint-disable-next-line @typescript-eslint/no-require-imports
const fs = require('fs');
// eslint-disable-next-line @typescript-eslint/no-require-imports
const { paths } = require('../config/codegen.config');
// eslint-disable-next-line @typescript-eslint/no-require-imports
const tailSafeConfig = require('../config/tailSafe.config.ts').default;

// paths
const generatedTypesPath = paths.generated.types;
const generatedColorsPath = paths.generated.colors;
const outputPath = paths.generated.groups;
const tailSafeTypePath = paths.generated.tailSafeInterface;

// Helper to extract all classnames from the generated types
function extractClassnames(filePath) {
  const content = fs.readFileSync(filePath, 'utf8');
  // For each line like | 'foo', it will extract just the value inside the quotes (foo)
  const matches = [...content.matchAll(/\|\s*'([^']+)'/g)];
  return matches.map(m => m[1]);
}

// Combine all classnames from both generated files
const classnames = [
  ...extractClassnames(generatedTypesPath),
  ...extractClassnames(generatedColorsPath),
];

// Group classnames by prefix before the first dash
const groupMap = {};
const allPropInterfaces = [];
for (const cn of classnames) {
  let working = cn;

  // If class starts with '-', remove the leading dash for negative classes
  if (working.startsWith('-')) {
    working = working.slice(1); // Remove leading dash for negative classes
  }
  const dashIdx = working.indexOf('-');
  if (dashIdx === -1) {
    // No dash: use the whole classname as the prefix
    const prefix = working;
    // If grouping does not yet exist, create a grouping
    if (!groupMap[prefix]) groupMap[prefix] = [];
    groupMap[prefix].push(cn);
    continue;
  }

  // If there is a dash in the classname, extract the prefix 
  const prefix = working.slice(0, dashIdx);
  // If grouping does not yet exist, create a grouping
  if (!groupMap[prefix]) groupMap[prefix] = [];
  groupMap[prefix].push(cn);
}

// Generate types and interfaces
let output = `// AUTO-GENERATED FILE. DO NOT EDIT.\n// Generated by tailSafe ðŸ¦ˆ\n\n`;
for (const prefix of Object.keys(groupMap).sort()) {
  const typeName = `${capitalize(prefix)}Class`;
  const interfaceName = `${capitalize(prefix)}Props`;
  allPropInterfaces.push(interfaceName);
  const values = groupMap[prefix];
  if (values.length === 0) continue;
  output += `export type ${typeName} =\n  | '${values.join("'\n  | '")}'\n;\n\n`;

  // Dynamically detect boolean utility props
  // If only one value, or the prefix itself is a value, allow boolean
  const isBooleanUtility =
    values.length === 1 || values.includes(prefix) || values.includes(`${prefix}-`) || prefix in tailSafeConfig.aliases;
  const propType = isBooleanUtility ? `${typeName} | boolean` : typeName;
  // The prefix MUST be quoted to handle reserved keywords like 'in'.
  output += `export interface ${interfaceName} {\n  '${prefix}'?: ${propType};\n}\n\n`;
}

// Add alias props as interfaces
for (const [alias] of Object.entries(tailSafeConfig.aliases)) {
  if (!groupMap.hasOwnProperty(alias)) {
    let interfaceName;
    const dashIdx = alias.indexOf('-');
    if (dashIdx === -1) {
      interfaceName = `${capitalize(alias)}AliasProps`;
    } else {
      const nameStrings = alias.split('-');
      const nameCamelCase = nameStrings.map((s) => capitalize(s)).join('');
      interfaceName = `${nameCamelCase}AliasProps`;
    }

    allPropInterfaces.push(interfaceName);
    output += `/**\n * ${interfaceName} alias\n */\n`;
    output += `export interface ${interfaceName} {\n  '${alias}'?: boolean;\n}\n\n`;
  }
}

function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

fs.writeFileSync(outputPath, output);

// eslint-disable-next-line no-console
console.log('âœ… Generated grouped Tailwind types and interfaces, written to', outputPath);

// Step 2: Generate the final TailSafe interface
const tailSafeContent = `// AUTO-GENERATED FILE. DO NOT EDIT.
// Generated by tailSafe ðŸ¦ˆ

import {
${allPropInterfaces.sort().map(name => `  ${name}`).join(',\n')}
} from './generatedTailwindGroups';

export interface TailSafe extends
${allPropInterfaces.sort().map(name => `  ${name}`).join(',\n')}
{
  /**
   * Optional className to pass to the element.
   * Will be merged with any classes generated from TailSafe props.
   */
  className?: string;
}
`;

fs.writeFileSync(tailSafeTypePath, tailSafeContent);

// eslint-disable-next-line no-console
console.log('âœ… Generated TailSafe interface, written to', tailSafeTypePath);