// scripts/generate-tailwind-mapping.js
// eslint-disable-next-line @typescript-eslint/no-require-imports
const fs = require('fs');
// eslint-disable-next-line @typescript-eslint/no-require-imports
const { paths } = require('../config/codegen.config');
// eslint-disable-next-line @typescript-eslint/no-require-imports
const { execSync } = require('child_process');

const tailwindCliPath = require.resolve('tailwindcss');

const inputCss = paths.config.inputCss;
const outputCss = paths.generated.outputCss;
const configJs = paths.config.tailwind;
const dtsOutPath = paths.generated.types;

// 1. Run Tailwind CLI to generate output.css
// eslint-disable-next-line no-console
console.log('Generating output.css with Tailwind CLI...');
try {
  execSync(`node ${tailwindCliPath} -i ${inputCss} -o ${outputCss} --config ${configJs}`, { stdio: 'inherit' });
} catch (e) {
  // eslint-disable-next-line no-console
  console.error('Failed to run Tailwind CLI with npx. Make sure @tailwindcss/cli is installed and accessible.');
  process.exit(1);
}

// 2. Parse output.css for class selectors
// eslint-disable-next-line no-console
console.log('Parsing output.css for class selectors...');
const css = fs.readFileSync(outputCss, 'utf8');

// Regex: match class selectors ending at whitespace, comma, or curly brace
const classRegex = /\.(-?[_a-zA-Z]+[_a-zA-Z0-9-]*(?:\\:[^\s.{:]*)?)(?=[\s,{])/g;

const classes = new Set();
let match;
while ((match = classRegex.exec(css)) !== null) {
  let className = match[1]
    .replace(/\\:/g, ':')
    .replace(/\\\[/g, '[')
    .replace(/\\\]/g, ']')
    .replace(/\\\//g, '/');

  // Filter out partials and invalids
  if (
    className &&
    !className.endsWith('-') &&
    !className.endsWith(':') &&
    !className.endsWith('[') &&
    !className.endsWith("'") &&
    !className.endsWith('\\') &&
    !className.includes("'") &&
    !className.includes('com') && // accidental match for 'com'
    !/^\d+$/.test(className) // skip pure numbers
  ) {
    classes.add(className);
  }
}

// 3. Extract variant prefixes dynamically
const variantRegex = /\.([a-zA-Z0-9_-]+)\\:/g;
const variants = new Set();
while ((match = variantRegex.exec(css)) !== null) {
  variants.add(match[1]);
}
const variantPrefixes = Array.from(variants);
const variantPrefixType = `export type VariantPrefix = ${variantPrefixes.map(v => `'${v}'`).join(' | ')};`;

// Helper to check if a class starts with a variant prefix and a colon
function isVariantClass(className) {
  return variantPrefixes.some(v => className.startsWith(v + ':'));
}

// 4. Add template literal types for arbitrary value utilities and number utilities
const knownArbitraryValueUtilities = [
  // Spacing/Sizing
  'm', 'mx', 'my', 'mt', 'mb', 'ml', 'mr',
  'p', 'px', 'py', 'pt', 'pb', 'pl', 'pr',
  'space-x', 'space-y', 'gap', 'w', 'min-w', 'max-w', 'h', 'min-h', 'max-h',
  'inset', 'inset-x', 'inset-y', 'top', 'right', 'bottom', 'left',

  // Typography
  'font', 'leading', 'tracking', 'line-clamp',

  // Border
  'border-x', 'border-y', 'border-t', 'border-b', 'border-l', 'border-r',
  'rounded', 'rounded-t', 'rounded-b', 'rounded-l', 'rounded-r', 'rounded-tl', 'rounded-tr', 'rounded-bl', 'rounded-br',

  // Flex/Grid
  'flex', 'order', 'grid-cols', 'grid-rows', 'col-span', 'row-span', 'col-start', 'row-start', 'col-end', 'row-end', 'auto-cols', 'auto-rows',

  // Effects
  'opacity', 'blur', 'brightness', 'contrast', 'drop-shadow', 'grayscale', 'hue-rotate', 'invert', 'saturate', 'sepia',
  'backdrop-blur', 'backdrop-brightness', 'backdrop-contrast', 'backdrop-grayscale', 'backdrop-hue-rotate', 'backdrop-invert', 'backdrop-opacity', 'backdrop-saturate', 'backdrop-sepia',

  // Transforms
  'scale', 'rotate', 'translate-x', 'translate-y', 'skew-x', 'skew-y',

  // Transitions/Animations
  'transition', 'duration', 'delay', 'ease', 'animate',

  // Miscellaneous
  'z', 'aspect', 'cursor', 'select', 'pointer-events', 'resize', 'scroll-m', 'scroll-p', 'outline-offset', 'outline-width', 'outline-color', 'outline-style', 'object', 'object-position', 'overflow', 'overscroll', 'place-content', 'place-items', 'place-self', 'will-change'
];
const arbitraryTemplates = Array.from(new Set(knownArbitraryValueUtilities)).sort().map(util => `| \`${util}-[\${'string'}]\``);
const numberValueUtilities = ['h', 'w', 'min-h', 'min-w', 'max-h', 'max-w'];
const numberTemplates = numberValueUtilities.map(util => `| \`${util}-\${number}\``);

// 5. Generate recursive variant type
const variantClassType = (baseType = 'TailwindClass') => `
export type VariantClass<T extends string = ${baseType}> =
  | T
  | \`\${VariantPrefix}:\${T}\`
  | \`\${VariantPrefix}:\${VariantPrefix}:\${T}\`;
`;

// 6. Generate TypeScript type
// eslint-disable-next-line no-console
console.log('Generating TypeScript type...');
const typeDef = `// AUTO-GENERATED FILE. DO NOT EDIT.
// Generated by tailSafe ðŸ¦ˆ 

${variantPrefixType}

export type TailwindClass =
  ${[...classes].filter(cn => !isVariantClass(cn)).map(cn => `| '${cn}'`).join('\n  ')}
  // Arbitrary value utilities
  ${arbitraryTemplates.join('\n  ')}
  // Numeric value utilities
  ${numberTemplates.join('\n  ')}
  
  ${variantClassType('TailwindClass')};
`;

fs.writeFileSync(dtsOutPath, typeDef, 'utf8');
// eslint-disable-next-line no-console
console.log('âœ… TypeScript type definition written to', dtsOutPath);